package main

import (
	"flag"
	"fmt"
	"github.com/gmm1900/deptrace/service"
	"log"
)

func main() {
	var pathToFile, dependencyModule *string
	var topLevels *int
	pathToFile = flag.String("f", "", "required: path to the file generated by command go mod graph, e.g., /path/to/file")
	dependencyModule = flag.String("m", "", "required: module (with or without version) that dependency path to be searched, e.g., github.com/go-kit/kit@v0.10.0")
	topLevels = flag.Int("l", 3, "optional: number of levels to extract distinct top level paths and their count")
	flag.Parse()

	if pathToFile == nil || *pathToFile == "" || dependencyModule == nil || *dependencyModule == "" {
		flag.Usage()
		return
	}

	//dependencyModule := "golang.org/x/crypto"
	//pathToFile := "/Users/pguz092c/go/src/code.in.spdigital.sg/guozaiyi/exp/deptrace/reef_go_mod_graph"

	inputs, err := service.ParseFile(*pathToFile)
	if err != nil {
		log.Fatal(err)
	}
	log.Println("file parsed")

	tree := service.Analyze(inputs)
	log.Println("tree analyzed")

	versionedModules, dependencyPaths := tree.SearchPath(*dependencyModule)
	log.Printf("found %d dependency paths to %s (%d versions)", len(dependencyPaths), *dependencyModule, len(versionedModules))

	topPathStats := service.ExtractTopPaths(dependencyPaths, *topLevels)
	log.Printf("found %d distinct top level paths to %s", len(topPathStats), *dependencyModule)

	for i := range versionedModules {
		fmt.Println(versionedModules[i].ToString())
	}
	fmt.Println("============================================")
	for i := range dependencyPaths {
		pathLength := len(dependencyPaths[i])
		fmt.Println()
		fmt.Println("path", i, "from root to", dependencyPaths[i][pathLength-1], ":")
		dependencyPaths[i].Print()
	}

	fmt.Println("============================================")
	for i := range topPathStats {
		fmt.Println()
		fmt.Println("distinct top path", i, "occurs", topPathStats[i].Count, "time(s)")
		topPathStats[i].DependencyPath.Print()
	}
}